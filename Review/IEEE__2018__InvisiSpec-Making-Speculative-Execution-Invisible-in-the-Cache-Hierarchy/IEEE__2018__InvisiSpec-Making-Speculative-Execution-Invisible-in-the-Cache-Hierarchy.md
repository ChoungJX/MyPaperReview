# Linfeng Zheng (2021-01-14)

# Paper information

* Title: InvisiSpec: Making Speculative Execution Invisible in the Cache Hierarchy
* Authors: Mengjia Yan, Jiho Choi, Dimitrios Skarlatos, Adam Morrison, Christopher Fletcher, Josep Torrellas
* Venue:
* Keywords: hardware security, speculation, side channel, memory hierarchy

# Paper content

## summary

This paper proposes *InvisiSpec* to block microarchitecture covert and side channels due to *speculative execution* and *Out of Order execution*.

---

Most of the *Speculative Execution Attacks* exploit the fact that *Speculative Execution* changes the cache hierarchy state even though it would be squashed later. This paper's key idea is preventing speculative instructions to change the cache hierarchy state until they cannot create side channels.

Some speculative load instructions request the value from the main memory, and microarchitecture put it into the cache for better performance in the next loads, which cause the cache state to change. In this paper, these *Load* instructions are called *Unsafe Speculative Loads* (USLs). *InvisiSpec* put the cached values (generated by USLs) into a specific buffer instead of the cache hierarchy (make USLs invisible). After USLs become safe (they cannot create any side channel), move values from specific buffer to cache hierarchy (make USLs visible). Furthermore, there are different definitions for USL in different attack models.

* For *Spectre* attack model, USLs belong to control-flow instructions that have not been resolved. After their control-flow instructions are resolved, they become safe.
* For *Futuristic* attack model, which can exploit any speculative load instructions, the USL has a more strict definition. A *Load* is a USL until it becomes either:
  * due to it has arrived at the head of *Re-Order Buffer* (ROB)

  or
  
  * although it does not arrive at the head of ROB, its prior instructions cannot make them be squashed.

---

Key mechanisms:

* **Speculative Buffer (SB) in L1 cache** stores values for USLs until they become safe.

  SB consists of *Load Queue entries* and *Speculative Buffer entries*, and there is a one-to-one mapping between LQ and SB entries. LQ store addresses the USLs needed and the Status Bit needed by the later operation. Each SB entry stores one cache line and an address mask specified by its LQ entry to state which value is needed by USL.
* ***Spec-GetS* transactions** get copies of cache lines without changing the cache hierarchy state.

  The standard coherence transaction could change the cache hierarchy state, which would create side channels. Therefore, *InvisiSpec* introduces a new transaction called *Spec-GetS* to avoid the cache hierarchy state changed when putting cache value copies into SB. *Spec-GetS* requests a copy of a cache line from the owner that owns this cache line. If this owner lost ownership when this request reached, *Spec-GetS* could request again until it gets the copy or its USL becomes safe then switch to the standard transaction.
* ***Validation* or *Exposure* of a USL** makes a USL visible and maintain memory consistency.

  If a USL needs *Validation*, it could have violated the memory consistency while it was in the invisible state. There are different standards of judgment for different memory consistency models to judge if a USL needs *Validation*.
  * In *Total Store Order* (TSO) model, it only allows *store* --> *load* reordering.

    A USL needs *Validation* when there are prior load instructions or fences in ROB.
  * In *Release Consistency* (RC) model, all reordering is allowed.

    Therefore, a USL needs *Validation* when there are prior fences in ROB.

  Once a USL needs *Validation*, *InvisiSpec* validates whether the value in its SB is equal to the newest value being read from the cache hierarchy. If they are equal, this USL can become visible, *InvisiSpec* will move SB's value into the cache hierarchy. Otherwise, this USL and all its successive instructions would be squashed.

  Suppose a USL does not need Validation. *InvisiSpec* will move its SB's value to the cache hierarchy without comparison, which is called *Exposure*.
* **Per-Core Last Level Cache Speculative Buffer (LLC-SB)** is used to speed up main memory access when USLs face Validation or Exposure.

  A USL would access main memory twice if:
  * its needed data did not exist in the cache hierarchy when it wants to move data into SB,

  meanwhile
  * it needs Validation.

  This paper introduces the LLC-SB to store the value when USLs read data from the main memory for the first time to avoid this situation. When a USL needs *Validation*, *InvisiSpec* reads data from LLC-SB instead of reading from the main memory again.

  ---

  The Key conclusion:

  *InvisiSpec* can defend against *Spectre* attacks and *Futuristic* attacks with some performance decrease. However, its performance is faster than using fences.

## Strengths

Almost all methods of defending against *Speculative Execution Attacks* will reduce the execution performance included *InvisiSpec*. However, *InvisiSpec* alleviates the execution slowdown by some mechanisms.

* **reusing the *Speculative Buffer***

  If a USL requests a cache line from the cache hierarchy, but this cache line has been stored into another SB entry, it just copies this cache line from that SB entry.
* **Overlapping Validations and Exposures**

  When overlapping *Validations* and *Exposures*, there are two limitations to ensure correctness and security:
  * Strictly following the memory consistency model.
  * USLs that could be squashed later cannot change the cache hierarchy state.

    This limitation only limits the *Futuristic* attack model. For *Spectre* attack model, USLs are unsafe only when they belong to the false branch instructions. After they become safe and can get *Validation* or *Exposure*, there would not be a problem even they are squashed due to memory consistency strategies.

Furthermore, *LLC-SB* is extremely safe. It speeds up access only for USLs' *Validations* and *Exposures*. For other situations, access requests will skip it and obtain value in the main memory to prevent new side channels.

## Weaknesses

* *InvisiSpec* reduces performance.

  Whether a USL needs *Validation* or *Exposure*, it has to access the cache (even the main memory) twice (one more time than normal instruction). In *Validation*, it needs to compare the value in SB and the cache, which spend more time. What is worse than in *Futuristic* attack model, a *Validation* cannot overlap with other *Validations* and *Exposures* because it would be squashed so that all successive USLs would be squashed too.
* *InvisiSpec* has execution overhead.

  The comparison in *Validation* will execute extra instructions. Moreover, *InvisiSpec* will allocate an SB entry for every load instruction issued, even though some are not speculative. These mechanisms need more operations, plus additional caches are introduced, *InvisiSpec* would consume more energy.

## Thoughts

I think *InvisiSpec* is a complete solution, but there is room for improvement in some mechanisms.

* Reduce execution overhead.

  *InvisiSpec* will allocate an SB entry for every load instruction issued, then set 'N' flag in Status bit if a load instruction is not speculative. The better way is allocating an SB entry after a load instruction is determined to be speculative.
* *LLC-SB* seems that not necessary.

  *LLC-SB* is used to speed up obtaining data when USLs in *Validation*. Why not add some bits in cache hierarchy instead of it? For example, adding one bit to announce that this cache line is used for *Validation* and prohibiting any instruction accessing it.

## Takeaways and questions

*InvisiSpec*'s key idea is straightforward: because the cache hierarchy creates side channels, there will be no problem after hiding the cache hierarchy state. However, there are many details to be worked out in implementation. *InvisiSpec* considered many aspects, like the memory consistency model, the cache consistency model, delay the interruption and TLB access, etc. Through this paper, I learned the feature of the speculative attack model and details about memory consistency.

**Question**:

* Why *Speculative Buffer* copies a cache line and sets an address mask, not store the value only?
* When a USL wants a cache line requested by other entries but does not reach SB, this USL will modify *MSHR*, which is complex. Why not wait for the value to reach SB then copy it?